---
title: '@JAVA基础: 类加载机制与反射'
comments: true
categories: languages
tags: java
abbrlink: 377ffef3
date: 2018-01-15 20:13:39
updated: 2018-02-01 18:09:42
keywords:
description:
---

当调用 Java 命令运行某个 Java 程序时，该命令会启动一个 Java 虚拟机进程，不管该 Java 程序有多么复杂，该 Java 程序启动了多少个线程，它们都处于该 Java 虚拟机进程里，同一个 JVM 的所有线程、所有变量都在都处于同一个进程，它们都是用该 JVM 进程的内存区。两个 JVM 之间并不会共享数据。

当系统出现以下情况时，JVM 进程将被终止：

- 程序运行到最后正常结束
- 程序运行到使用 System.exit() 或 Runtime.getRuntime().exit()代码处结束进程
- 程序执行过程中遇到未捕获的异常或错误而结束
- 程序所在平台强制结束了 JVM 进程

## 类的加载、连接和初始化

当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 *加载、连接、初始* 三个步骤来dUI 该类进行初始化，若不出意外，JVM 会连续完成这三个步骤，这三个步骤统称为 _*“类加载/类初始化”*_。

JVM 初始化一个类包含以下步骤：

- 若这个类没有被加载和连接，则程序先加载并连接该类
- 若该类的直接父类没有被初始化，则先初始化其直接父类
- 若类中又初始化语句，则系统依次执行这些初始化语句

（所以 JVM 最先初始化的总是 java.lang.Object 类）

### 类的加载

**类加载指的是将类的 `class` 文件读入内存，并为之创建一个 `java.lang.Class` 对象**。

类的加载由类加载器完成，类加载器通常由 JVM 提供，JVM 提供的这些类加载器 —— 即 _*系统类加载器*_。开发者可通过继承 `java.lang.ClassLoader` 基类来创建自己的类加载器。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种*来源*：

- 从本地文件系统加载 `*.class` 文件
- 从 JAR 包加载 class 文件
- 通过网络加载 class 文件
- 把一个 Java 源文件（即 `*.java`文件）动态编译，并执行加载

类加载器通常无需等到“首次使用”该类时才会加载该类，JVM规范允许虚拟机预先加载某些类。

### 类的连接

连接阶段负责把“加载阶段”生成的二进制数据合并到 JRE 中，类连接又分为如下三个阶段：

- 验证：校验被加载的类是否有正确的内部结构
- 准备：为类的类变量分配内存，并设置默认初始值
- 解析：将类的二进制数据中的符号引用转化为直接引用

### 类的初始化

在类的初始化阶段，主要是负责对类变量进行初始化。

类变量的初始化有两种方式：

- 声明类变量时指定初始值
- 使用静态初始化块指定初始值

**宏变量**和**静态变量**的区别？
当某个类变量（也叫静态变量）使用了 final 修饰，而且他的值可以在编译时被确定下来（这样的类变量即 宏变量），那么程序其它地方使用该类变量时，实际上并没有使用该类变量，而是相当于使用常量，编译器会在编译时，在用到该变量的地方直接替换成该变量的值，故，不需要进行类的初始化即可访问其类变量。


## 类加载器

**如何定位一个类？**
在 Java 中，一个类用其全限定类名（包名和类名）作为标识；在 JVM 中，一个类用 全限定类名+类加载器 作为其唯一标识。

当 JVM 启动时，会形成由三个类加载器组成的初始类加载器层次结构：

- Bootstrap ClassLoader: 根类加载器。负责加载 Java 的核心库(如`$JAVA_HOME/jdk1.8.0_05/jre/lib/rt.jar`)
- Extension ClassLoader: 扩展类加载器。负责加载 JRE 的扩展类库(如`$JAVA_HOME/jdk1.8.0_05/jre/lib/ext/...`)
- System ClassLoader: 系统类加载器。负责在 JVM 启动时加载来自 Java 命令的 -classpath...

![](http://ipic-markdown.oss-cn-shanghai.aliyuncs.com/blog/2018-01-11-115945.png)

类加载器之间的父子关系并不是继承上的父子关系，这里的父子关系是类加载器实例之间的关系。如下：

JVM 的根类加载器并不是 JAVA 实现的，JVM 中除根类加载器之外的所有类加载器都是 ClassLoader 子类的实例，开发者可通过继承 ClassLoader 类，并重写其中的 `loadClass(String name, boolean resolve)` 或 `findClass(String name)`来自定义类加载器。

## 反射
### 通过反射查看类信息

Java 程序的许多对象在运行时都会出现两种类型：编译时类型和运行时类型，例如：
`Person p = new Student();`,这行代码的 p 变量，在编译时类型为 Person，运行时类型为 Student，为了解决这个问题，程序需要在运行时发现对象和类的真实信息。

step1: 获得 Class 对象
step2: 从 Class 中获取信息

- 获得构造器
- 获得方法
- 获得成员变量
- 获得注解
- 获得内部类
- 该 Class 对象所对应类的修饰符、所在包、类名等信息
- 判断该类是否为借口、枚举、注解类型等

### 使用反射生成并操作对象

通过反射创建对象有两种方式：

- 使用 Class 对象的 newInstance() 方法来创建该 Class 对象所对应类的实例。该方式要求该 Class 对象的对应类有默认构造器。
- 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法 来创建该 Class 对象所对应类的实例。该方式可以自己选择使用哪个构造器创建实例。

java.lang.reflect 包下还提供了 Array 类，Array 对象可以代表所有的数组，程序可以通过s 会用 Array 来动态地创建数组，操作数组元素。

## 参考

- 李刚.疯狂Java讲义 第3版.北京：电子工业出版社,2014.07.


